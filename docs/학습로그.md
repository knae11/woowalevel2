# 학습로그

# [DB] 트랜잭션
## 데드락
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
- [참고링크 - 데이터베이스에서 데드락](https://myjamong.tistory.com/181)
- 락이 걸려있는 것들 끼리 자료수정이 같이 일어나면, lock 되어 있는 상태에서 데드락이 발생할 가능성이 있는 것 같음
- 격리수준이 높을 수록 락의 가능성이 높아짐?!
- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있는 현상
- [참고링크](https://mangkyu.tistory.com/30)
- 한 테이블에서 순서없이 갱신하면 교착상태가 발생하기 쉽다. 갱신을 직렬화하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

## 격리수준(isolation level)
- `@Transactional`에 걸리는 격리수준의 기본설정은 DB의 기본 설정을 따른다.
- READ_UNCOMMITTED: 가장 낮은 수준의 격리수준
- READ_COMMITTED: dirty read 를 막아줌. commit 된 내용만 read 가능(트랜잭션 시, 다른 부분이 커밋되면 변경된 내용으로 읽기 가능)
- REPEATABLE_READ: 세번째 수준의 격리수준. 처음 읽기 시작할 시점의 커밋된 내용만 read 가능
- SERIALIZABLE: 가장 높은 격리수준으로 read에도 lock을 생성

## 전파속성(propagation)
- 이제 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성
- REQUIRED: default. 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 새로운 트랜잭션을 발생
- SUPPORTS: 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 트랜잭션 없이 진행
- MANDATORY: 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 예외를 발생
- NEVER: 활성된 트랜잭션이 있다면 예외를 발생
- NOT_SUPPORTED: 활성된 트랜잭션이 있다면 보류시킴
- REQUIRES_NEW: 활성된 트랜잭션이 있다면 보류시키고 새 트랜잭션을 생성
- NESTED: 이미 진행중인 트랜잭션이 있다면, save point 를 마크함. 그리고 중첩 트랜잭션을 실행
- [propagation - bealdung blog](https://www.baeldung.com/spring-transactional-propagation-isolation)

## 태그
- DB, 트랜잭션, 데드락

# [Spring] `@Bean`, `@Component`
## `@Bean` VS `@Component`
- `@Bean`
    - 외부 라이브러리들을 Bean 으로 등록하고 싶은 경우에 사용
    - 메소드 단위, 어노테이션 단위에 붙일 수 있음, 클래스 단위는 불가함
    - 인스턴스를 생성하는 메소드를 만들고 해당 메소드에 `@Bean`을 선언하여 Bean 으로 등록
    - `@Bean`은 `@Configuration`이 붙은 DI 설정용 클래스에서 주로 사용하는 것으로, 메소드를 이용해서 빈 오브젝트의 생성과 의존관계 주입을 직접 자바코드르 작성
    - `@Configuration` 자바 클래스에서 정의한 빈과 XML 에서 정의한 빈은 얼마든지 서로 참조가 가능 
    - 스캔할 필요 없이 빈 등록이 빠르게 이루어짐
    - [스프링 공식문서 Bean](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts)
- `@Component`
    - 개발자가 직접 컨트롤이 가능한 Class 들의 경우
    - 빈으로 등록될 후보 클래스에 붙여주는 일종의 마커
    - `@Component`가 있는 클래스를 찾아서 빈으로 등록하려면 빈 스캔 기능을 사용하겠다는 어노테이션 정의가 필요
    - 컴포넌트 어노테이션이 있는 클래스를 찾아서 빈으로 등록하는 건 부담가는 작업
    - 특정 패키지 아래서만 찾도록 기준이 되는 패키지를 지정하는 것이 좋음 -> `@ComponentScan`을 사용
    - `@Autowired`로 찾을 대상이 두 개 이상인 경우(같은 타입의 빈이 두개 이상인 경우), 이름을 기준으로 빈을 등록해야하기 때문에 빈의 아이디가 중요해짐
    - 이럴때, 클래스 이름 대신 빈의 아이디로 사용하고 싶다면 `@Component("userDao")`처럼 애노테이션에 이름을 넣어주면 됨 (토비의 스프링:678pg)
    - [스프링 공식문서 Component](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-stereotype-annotations)
    - `@Configuration`도 `@Bean`이다.
  
- 둘 간의 큰 성능차이는 없는 것 같다. Bean 으로 등록하는 방식이 더 오래된 방식 같으며, 외부 라이브러리에는 `@Component`를 사용할 수 없어 인스턴스를 만들어 `@Bean`으로 등록
- [bean, component](https://jojoldu.tistory.com/27)
- 토비의 스프링 7장
## `@Resource` VS `@Autowired`
- 빈 등록
- `@Autowired`: 필드의 타입으로 기준으로 빈을 찾음
- `@Resource`: 필드의 이름 기준으로 빈을 찾음

## 태그
- 빈 등록

# [Test] `@Nested`

## `@Nested` 계층적 테스트 구조
- 해당 어노테이션을 사용하여 계층적 테스트 구조를 생성가능
- [사용법 참고 블로그](https://johngrib.github.io/wiki/junit5-nested/#junit5%EC%9D%98-nested%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EC%9E%90)
- [junit @Nested](https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested)
## 태그
- nested, 테스트

# 학습로그 - 2

# \[Spring] Lite Bean Mode

## 빈 등록 - Lite Bean Mode
- [참고 블로그](https://multifrontgarden.tistory.com/253)
- [Spring docs - Bean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html)
- `@Configuration` 대신 `@Component` 어노테이션을 붙이면 Lite mode 로 빈이 생성됨
- 컨테이너에 의해 일반 팩토리 메소드로 관리됨 (XML 설정으로 선언하는 것과 비슷) 제약조건등이 관리되지 않음
- 내부 빈 참조가 지원되지 않으나 `@Bean-method`가 다른 `@Bean-method`를 lite mode 로 작동시킴
- CGLIB 프록시 객체가 아닌 일반 객체로 관리됨(`@Configuration`을 사용하면 CGLIB 바이트 코드를 조작하여 메소드 호출이 1회만 일어나게 만듦)
> Bean methods in lite mode will be treated as plain factory methods by the container (similar to factory-method declarations in XML), with scoping and lifecycle callbacks properly applied. 
> The containing class remains unmodified in this case, and there are no unusual constraints for the containing class or the factory methods.
> In contrast to the semantics for bean methods in @Configuration classes, 'inter-bean references' are not supported in lite mode. 
> Instead, when one @Bean-method invokes another @Bean-method in lite mode, the invocation is a standard Java method invocation; 
> Spring does not intercept the invocation via a CGLIB proxy. 
> This is analogous to inter-@Transactional method calls where in proxy mode, Spring does not intercept the invocation — Spring does so only in AspectJ mode.

- [spring docs - configuration vs lite](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts)
- `@Configuration`에서 `@Bean`을 관리하면, 동일한 `@Bean` 메소드가 Java 호출을 통해 실수로 호출되는 것을 방지하여 lite mode 에서 찾기 힘든 버그를 줄일 수 있음

## CGLIB
- [spring docs - CGLIB](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop)
> CGLIB proxies intercept only public method calls! Do not call non-public methods on such a proxy. 
> They are not delegated to the actual scoped target object.

## 태그
- 빈 등록, Configuration, Bean, Component, CGLIB

# \[DB] Transaction

## 트랜잭션

- 단일 쿼리문은 자체로 트랜잭션이 적용됨
- 성공하면 커밋, 실패하면 롤백

## 태그
- transaction

# \[DB] Cardinality
## 카디널리티(SQL statements)
- [wikipedia](https://en.wikipedia.org/wiki/Cardinality_(SQL_statements))
- 카디널리티가 낮을수록 더 많은 중복요소
- 카디널리티가 높다 -> 중복 요소가 적다
- 고유성을 가지는 tuple 의 데이터 값들을 의미
- [stackoverflow cardinality](https://stackoverflow.com/questions/25548029/what-is-the-definition-of-cardinality-in-sql/56738927)

## 태그
- DB, cardinality

