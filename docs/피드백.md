# 피드백

1. 클래스 단위의 `@Transactional` 사용
- 저는 개인적으로 클래스 레벨에 Transactional을 사용하는 것을 선호하지 않습니다
  트랜잭션은 굉장히 비용이 큰 작업이고, 불필요한 트랜잭션으로 성능이 낮아지는 문제도 있지만 더 큰 문제는 의도되지 않은 트랜잭션으로 인해 데드락이 발생할 수 있다 라는 것이 생각입니다
  실제 현업에서 대규모 트래픽을 처리하기 위해 데드락이 발생하지 않도록 설계하는 것이 굉장히 중요한데요
  개발하는 과정에서도 이 기능에 데드락이 발생할 요소가 있을까? 트랜잭션을 꼭 잡아야 가능한 기능일까? 구조를 변경하여 락이 필요 없는 구조로 바꿀 수 없을까? 에 대해 끊임없이 고민하게 되는데, 이러한 고민을 하는 시점이 저는 메서드에 Transactional 처리를 하는 시점에 가장 많이 하는 것 같습니다
  
  또한 클래스마다 트랜잭션과 격리레벨이 정해지는 것이 아닌 기능(메서드)단위로 처리되기 때문에 클래스에 적용하여 공통으로 처리할 필요가 있을까? 라는 의문이 들었습니다 ㅎㅎ

2. Q1. 요금 관련해서 로그인 사용자와 비로그인 사용자도 모두 접근 가능하게 해야 하더라구요. 이때, 방법을 잘 몰라서 지금은 null로 보내주고 null인지 체크를 하게 만들었는데ㅠㅠ null을 보내주는게 마음에 조금 걸려서요. Service 단에서 로그인 여부를 체크해서 다른 메소드를 불러주게 되어 있어서 null 자체를 넘길 수 밖에 없었어요. 나이 정보 때문에 이렇게 구성하게 되었는데, 혹시 더 좋은 방법이 있을지 궁금합니다.

- A1. 하나의 메서드에서 로그인에 따라 다르게 처리될 경우 지금과 같은 분리처리는 어쩔 수 없을 것 같습니다 T.T
Null Check 자체가 로그인을 확인하는 것이 명시적이지 않은 것이 문제라면, isLogin과 같은 기능을 추상화하여 로그인한 유저와 로그인하지 않은 유저로 나누어 처리할 수 있는 방법이 있을 것 같습니다
(혹은 Role에 대한 역할을 추가해봐도 되겠네요!!)

  이러한 처리는 일종의 Null Object Pattern과 같은 개념으로 해당 키워드로 검색해보면 좋을 것 같아요 ㅎㅎ

  조금 더 나아가서 API 설계 시, 누구나 접근할 수 있는 API와 로그인 한 유저만 접근할 수 있는 API 2개로 나누어 클라이언트에서 분기처리 하는 방법도 있답니다 :)

3. Q2. 지금 lines/{id}, lines/{id}/sections/~~ 이런식으로 체크하다 보니 lines와 관련된 모든 로직은 lineId에 대한 검증로직을 추가해주어야 하더라구요. 모든 곳에 중복되서 validate 가 들어가는데 혹시 더 개선하는 방향이 있나요? 아니면 보통 이렇게 매 메소드 호출시 Service 단에서 중복 검증로직을 추가해주는 편인가요?

- A2. line과 연관이 있는 부분이라면 같이 검증을 해주셔야 할 것 같습니다!
방법은 lineId와 sectionId를 같이 조회하는 방식 등으로 처리될 수도 있고, 다른 로직이 있을 수도 있을 것 같습니다 :)

# todos
- [x] 클래스 단위의 `@Transactional` 공부
- [x] 데드락 공부 -> DB와 데드락 더 공부해보기
- [x] 메서드 명 반환값(return)과 연관지어 다시 확인하기
- [x] `@Bean`, `@Component` 등록 차이는?
- [ ] 인터셉터가 설정이 가지는 의미와 `/path`?-->??
- [x] 예외처리 구조확인, handle
- [x] Distance 클래스?
- [x] 인수턴스 변수 초기화를 하나의 생성자로?
- [x] SectionResponse 정적팩토리메서드 명 수정
- [x] MemberService -> isPresent 로 끊어보기 (가독성 향상)
- [x] Fare 도메인에 대한 추상화(내용 추가시에도 코드 수정 안 할 수 있게)
- [x] `@nested` 테스트 공부
- [x] Null Object Pattern 찾아보기

# 피드백 - 2

## 데드락을 줄이는 방법
1. 최대한 락을 줄인다.
- 불필요한 락은 전부 없애고, 필요한 락이 있더라도 락이 안잡도록 구조를 잡을 수 없을까 고민한다.
- ex. 제약조건 확인과 같은 경우 별도 테이블을 분리하여 UNIQUE를 활용
-  락을 없앨 수 없다면 락을 잡는 시간을 최대한 줄인다.
2. 트랜잭션 내부 처리 순서를 일치시킨다.
- 송금기능을 구현한다 했을 때, A 트랜잭션은 출금->입금 순으로 진행하고 B 트랜잭션은 입금->출금 순으로 진행한다면, 동일한 처리순서를 가지도록 수정한다.
- 로직 순서에 의한 데드락을 방지한다.
3. 락은 Row Lock만 가지도록 설계한다.
- 하나의 로우에 여러 유저가 접근할 일을 최대한 줄인다.
- 유저 별 데이터가 존재한다면 데드락이 발생할 확률이 거의 없어지고 발생한다하여도 장애가 다른 유저에게 전파되지 않는다.
4. 여러 유저가 하나의 로우에 접근할 일이 있다면, 락을 잡지 않는 방식으로 작성한다.
- 락을 잡지 않는 쿼리를 보낸 후, affected rows와 같은 응답을 가지고 처리한다.
- ex) UPDATE group SET count = count + 1 WHERE id = {id};
- 이러한 변화에 따른 비즈니스 로직의 변경이나, 불필요한 데이터가 생기는 문제는 있기 때문에 적절한 트레이드 오프가 필요하다.
5. 불필요한 인덱스를 제거하고, 카디널리티가 높은 데이터를 인덱스로 잡는다.
- 적은 레코드를 스캔하면 데드락의 확률이 낮아진다.
6. 최대한 격리레벨을 낮춘다.
- 격리레벨에 따라 락의 메커니즘이 다르다.
- 대용량 분산처리를 하는 서비스의 경우 SERIALIZABLE은 꿈도 꾸지 않는다.

핵심은 데드락은 버그라는 생각을 버려야하고, 동시성에 대한 잠금처리를 위해 선택한 기술 중 하나라고 생각하는 것이 좋습니다.
동일한 데이터에 대해 접근하는 것에 대한 처리를 위해 데드락을 의도했다! 라는 관점으로 접근해보면 좋을 것 같습니다!

https://stackoverflow.com/questions/46230555/why-i-shouldnt-use-repeatable-read-with-locking-reading-select-for-update/46231651#46231651

데드락을 예방하는 방법으로 READ-COMMITTED 격리레벨을 사용 후 데드락 발생 시 재시도를 하도록 하는 것을 추천하는 내용입니다 ㅎㅎ
데드락은 피할 수 없기 때문에 같이 즐겨보아요..! T.T